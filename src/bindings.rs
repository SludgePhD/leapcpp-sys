/* automatically generated by rust-bindgen 0.59.1 */

pub type std_string = [u64; 4usize];
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
pub type __int32_t = ::std::os::raw::c_int;
pub type __int64_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub const Leap_PI: f32 = 3.1415927410125732;
pub const Leap_DEG_TO_RAD: f32 = 0.01745329238474369;
pub const Leap_RAD_TO_DEG: f32 = 57.295780181884766;
pub const Leap_EPSILON: f32 = 0.00000011920928955078125;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_Vector {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_Leap_Vector() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Vector>(),
        12usize,
        concat!("Size of: ", stringify!(Leap_Vector))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Vector>(),
        4usize,
        concat!("Alignment of ", stringify!(Leap_Vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Vector>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Vector),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Vector>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Vector),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Vector>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Vector),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_FloatArray {
    pub m_array: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_Leap_FloatArray() {
    assert_eq!(
        ::std::mem::size_of::<Leap_FloatArray>(),
        64usize,
        concat!("Size of: ", stringify!(Leap_FloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_FloatArray>(),
        4usize,
        concat!("Alignment of ", stringify!(Leap_FloatArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_FloatArray>())).m_array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_FloatArray),
            "::",
            stringify!(m_array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_Matrix {
    pub xBasis: Leap_Vector,
    pub yBasis: Leap_Vector,
    pub zBasis: Leap_Vector,
    pub origin: Leap_Vector,
}
#[test]
fn bindgen_test_layout_Leap_Matrix() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Matrix>(),
        48usize,
        concat!("Size of: ", stringify!(Leap_Matrix))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Matrix>(),
        4usize,
        concat!("Alignment of ", stringify!(Leap_Matrix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Matrix>())).xBasis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Matrix),
            "::",
            stringify!(xBasis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Matrix>())).yBasis as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Matrix),
            "::",
            stringify!(yBasis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Matrix>())).zBasis as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Matrix),
            "::",
            stringify!(zBasis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Matrix>())).origin as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Matrix),
            "::",
            stringify!(origin)
        )
    );
}
#[repr(C)]
pub struct Leap_Interface__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Interface {
    pub vtable_: *const Leap_Interface__bindgen_vtable,
    pub m_object: *mut SharedObject,
}
#[repr(C)]
pub struct Leap_Interface_Implementation__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Interface_Implementation {
    pub vtable_: *const Leap_Interface_Implementation__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_Leap_Interface_Implementation() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Interface_Implementation>(),
        8usize,
        concat!("Size of: ", stringify!(Leap_Interface_Implementation))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Interface_Implementation>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Interface_Implementation))
    );
}
#[test]
fn bindgen_test_layout_Leap_Interface() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Interface>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Interface))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Interface>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_Interface>())).m_object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_Interface),
            "::",
            stringify!(m_object)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9Interface13deleteCStringEPKc"]
    pub fn Leap_Interface_deleteCString(cstr: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9InterfaceC1EPv"]
    pub fn Leap_Interface_Interface(this: *mut Leap_Interface, owner: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9InterfaceC1EPNS0_14ImplementationEPv"]
    pub fn Leap_Interface_Interface1(
        this: *mut Leap_Interface,
        reference: *mut Leap_Interface_Implementation,
        owner: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9InterfaceC1ERKS0_"]
    pub fn Leap_Interface_Interface2(this: *mut Leap_Interface, rhs: *const Leap_Interface);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9InterfaceC1EPNS_12SharedObjectE"]
    pub fn Leap_Interface_Interface3(this: *mut Leap_Interface, object: *mut SharedObject);
}
impl Leap_Interface {
    #[inline]
    pub unsafe fn deleteCString(cstr: *const ::std::os::raw::c_char) {
        Leap_Interface_deleteCString(cstr)
    }
    #[inline]
    pub unsafe fn new(owner: *mut ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Interface_Interface(__bindgen_tmp.as_mut_ptr(), owner);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        reference: *mut Leap_Interface_Implementation,
        owner: *mut ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Interface_Interface1(__bindgen_tmp.as_mut_ptr(), reference, owner);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *const Leap_Interface) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Interface_Interface2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(object: *mut SharedObject) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Interface_Interface3(__bindgen_tmp.as_mut_ptr(), object);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9InterfaceD1Ev"]
    pub fn Leap_Interface_Interface_destructor(this: *mut Leap_Interface);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_PointableImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_BoneImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_FingerImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ToolImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_HandImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_GestureImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ScreenImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_DeviceImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ImageImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_InteractionBoxImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_BugReportImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_FrameImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ControllerImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_MaskImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_TrackedQuadImplementation {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ListBaseImplementation {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Pointable {
    pub _base: Leap_Interface,
}
pub const Leap_Pointable_Zone_ZONE_NONE: Leap_Pointable_Zone = 0;
pub const Leap_Pointable_Zone_ZONE_HOVERING: Leap_Pointable_Zone = 1;
pub const Leap_Pointable_Zone_ZONE_TOUCHING: Leap_Pointable_Zone = 2;
pub type Leap_Pointable_Zone = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Pointable() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Pointable>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Pointable))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Pointable>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Pointable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable2idEv"]
    pub fn Leap_Pointable_id(this: *const Leap_Pointable) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable5frameEv"]
    pub fn Leap_Pointable_frame(out: *mut Leap_Frame, this: *const Leap_Pointable);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable4handEv"]
    pub fn Leap_Pointable_hand(out: *mut Leap_Hand, this: *const Leap_Pointable);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable11tipPositionEv"]
    pub fn Leap_Pointable_tipPosition(this: *const Leap_Pointable) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable11tipVelocityEv"]
    pub fn Leap_Pointable_tipVelocity(this: *const Leap_Pointable) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable9directionEv"]
    pub fn Leap_Pointable_direction(this: *const Leap_Pointable) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable5widthEv"]
    pub fn Leap_Pointable_width(this: *const Leap_Pointable) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable6lengthEv"]
    pub fn Leap_Pointable_length(this: *const Leap_Pointable) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable8isFingerEv"]
    pub fn Leap_Pointable_isFinger(this: *const Leap_Pointable) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable6isToolEv"]
    pub fn Leap_Pointable_isTool(this: *const Leap_Pointable) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable10isExtendedEv"]
    pub fn Leap_Pointable_isExtended(this: *const Leap_Pointable) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable7isValidEv"]
    pub fn Leap_Pointable_isValid(this: *const Leap_Pointable) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable9touchZoneEv"]
    pub fn Leap_Pointable_touchZone(this: *const Leap_Pointable) -> Leap_Pointable_Zone;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable13touchDistanceEv"]
    pub fn Leap_Pointable_touchDistance(this: *const Leap_Pointable) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable21stabilizedTipPositionEv"]
    pub fn Leap_Pointable_stabilizedTipPosition(this: *const Leap_Pointable) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9Pointable11timeVisibleEv"]
    pub fn Leap_Pointable_timeVisible(this: *const Leap_Pointable) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9Pointable7invalidEv"]
    pub fn Leap_Pointable_invalid() -> *const Leap_Pointable;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9PointableC1EPNS_23PointableImplementationE"]
    pub fn Leap_Pointable_Pointable(
        this: *mut Leap_Pointable,
        arg1: *mut Leap_PointableImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9PointableC1EPNS_20FingerImplementationE"]
    pub fn Leap_Pointable_Pointable1(
        this: *mut Leap_Pointable,
        arg1: *mut Leap_FingerImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9PointableC1EPNS_18ToolImplementationE"]
    pub fn Leap_Pointable_Pointable2(this: *mut Leap_Pointable, arg1: *mut Leap_ToolImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9PointableC1Ev"]
    pub fn Leap_Pointable_Pointable3(this: *mut Leap_Pointable);
}
/*impl Leap_Pointable {
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Pointable_id(self)
    }
    #[inline]
    pub unsafe fn frame(&self) -> Leap_Frame {
        Leap_Pointable_frame(self)
    }
    #[inline]
    pub unsafe fn hand(&self) -> Leap_Hand {
        Leap_Pointable_hand(self)
    }
    #[inline]
    pub unsafe fn tipPosition(&self) -> Leap_Vector {
        Leap_Pointable_tipPosition(self)
    }
    #[inline]
    pub unsafe fn tipVelocity(&self) -> Leap_Vector {
        Leap_Pointable_tipVelocity(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_Pointable_direction(self)
    }
    #[inline]
    pub unsafe fn width(&self) -> f32 {
        Leap_Pointable_width(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> f32 {
        Leap_Pointable_length(self)
    }
    #[inline]
    pub unsafe fn isFinger(&self) -> bool {
        Leap_Pointable_isFinger(self)
    }
    #[inline]
    pub unsafe fn isTool(&self) -> bool {
        Leap_Pointable_isTool(self)
    }
    #[inline]
    pub unsafe fn isExtended(&self) -> bool {
        Leap_Pointable_isExtended(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Pointable_isValid(self)
    }
    #[inline]
    pub unsafe fn touchZone(&self) -> Leap_Pointable_Zone {
        Leap_Pointable_touchZone(self)
    }
    #[inline]
    pub unsafe fn touchDistance(&self) -> f32 {
        Leap_Pointable_touchDistance(self)
    }
    #[inline]
    pub unsafe fn stabilizedTipPosition(&self) -> Leap_Vector {
        Leap_Pointable_stabilizedTipPosition(self)
    }
    #[inline]
    pub unsafe fn timeVisible(&self) -> f32 {
        Leap_Pointable_timeVisible(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Pointable {
        Leap_Pointable_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_PointableImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Pointable_Pointable(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *mut Leap_FingerImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Pointable_Pointable1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut Leap_ToolImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Pointable_Pointable2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Pointable_Pointable3(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Arm {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_Arm() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Arm>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Arm))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Arm>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Arm))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm5widthEv"]
    pub fn Leap_Arm_width(this: *const Leap_Arm) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm9directionEv"]
    pub fn Leap_Arm_direction(this: *const Leap_Arm) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm5basisEv"]
    pub fn Leap_Arm_basis(this: *const Leap_Arm) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm13elbowPositionEv"]
    pub fn Leap_Arm_elbowPosition(this: *const Leap_Arm) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm13wristPositionEv"]
    pub fn Leap_Arm_wristPosition(this: *const Leap_Arm) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm6centerEv"]
    pub fn Leap_Arm_center(this: *const Leap_Arm) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap3Arm7isValidEv"]
    pub fn Leap_Arm_isValid(this: *const Leap_Arm) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap3Arm7invalidEv"]
    pub fn Leap_Arm_invalid() -> *const Leap_Arm;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap3ArmC1EPNS_18HandImplementationE"]
    pub fn Leap_Arm_Arm(this: *mut Leap_Arm, arg1: *mut Leap_HandImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap3ArmC1Ev"]
    pub fn Leap_Arm_Arm1(this: *mut Leap_Arm);
}
impl Leap_Arm {
    #[inline]
    pub unsafe fn width(&self) -> f32 {
        Leap_Arm_width(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_Arm_direction(self)
    }
    #[inline]
    pub unsafe fn basis(&self) -> Leap_Matrix {
        Leap_Arm_basis(self)
    }
    #[inline]
    pub unsafe fn elbowPosition(&self) -> Leap_Vector {
        Leap_Arm_elbowPosition(self)
    }
    #[inline]
    pub unsafe fn wristPosition(&self) -> Leap_Vector {
        Leap_Arm_wristPosition(self)
    }
    #[inline]
    pub unsafe fn center(&self) -> Leap_Vector {
        Leap_Arm_center(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Arm_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Arm {
        Leap_Arm_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_HandImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Arm_Arm(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Arm_Arm1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Bone {
    pub _base: Leap_Interface,
}
pub const Leap_Bone_Type_TYPE_METACARPAL: Leap_Bone_Type = 0;
pub const Leap_Bone_Type_TYPE_PROXIMAL: Leap_Bone_Type = 1;
pub const Leap_Bone_Type_TYPE_INTERMEDIATE: Leap_Bone_Type = 2;
pub const Leap_Bone_Type_TYPE_DISTAL: Leap_Bone_Type = 3;
pub type Leap_Bone_Type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Bone() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Bone>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Bone))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Bone>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Bone))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone9prevJointEv"]
    pub fn Leap_Bone_prevJoint(this: *const Leap_Bone) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone9nextJointEv"]
    pub fn Leap_Bone_nextJoint(this: *const Leap_Bone) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone6centerEv"]
    pub fn Leap_Bone_center(this: *const Leap_Bone) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone9directionEv"]
    pub fn Leap_Bone_direction(this: *const Leap_Bone) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone6lengthEv"]
    pub fn Leap_Bone_length(this: *const Leap_Bone) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone5widthEv"]
    pub fn Leap_Bone_width(this: *const Leap_Bone) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone4typeEv"]
    pub fn Leap_Bone_type(this: *const Leap_Bone) -> Leap_Bone_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone5basisEv"]
    pub fn Leap_Bone_basis(this: *const Leap_Bone) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Bone7isValidEv"]
    pub fn Leap_Bone_isValid(this: *const Leap_Bone) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4Bone7invalidEv"]
    pub fn Leap_Bone_invalid() -> *const Leap_Bone;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4BoneC1EPNS_18BoneImplementationE"]
    pub fn Leap_Bone_Bone(this: *mut Leap_Bone, arg1: *mut Leap_BoneImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4BoneC1Ev"]
    pub fn Leap_Bone_Bone1(this: *mut Leap_Bone);
}
impl Leap_Bone {
    #[inline]
    pub unsafe fn prevJoint(&self) -> Leap_Vector {
        Leap_Bone_prevJoint(self)
    }
    #[inline]
    pub unsafe fn nextJoint(&self) -> Leap_Vector {
        Leap_Bone_nextJoint(self)
    }
    #[inline]
    pub unsafe fn center(&self) -> Leap_Vector {
        Leap_Bone_center(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_Bone_direction(self)
    }
    #[inline]
    pub unsafe fn length(&self) -> f32 {
        Leap_Bone_length(self)
    }
    #[inline]
    pub unsafe fn width(&self) -> f32 {
        Leap_Bone_width(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> Leap_Bone_Type {
        Leap_Bone_type(self)
    }
    #[inline]
    pub unsafe fn basis(&self) -> Leap_Matrix {
        Leap_Bone_basis(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Bone_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Bone {
        Leap_Bone_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_BoneImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Bone_Bone(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Bone_Bone1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Finger {
    pub _base: Leap_Pointable,
}
pub const Leap_Finger_Joint_JOINT_MCP: Leap_Finger_Joint = 0;
pub const Leap_Finger_Joint_JOINT_PIP: Leap_Finger_Joint = 1;
pub const Leap_Finger_Joint_JOINT_DIP: Leap_Finger_Joint = 2;
pub const Leap_Finger_Joint_JOINT_TIP: Leap_Finger_Joint = 3;
pub type Leap_Finger_Joint = ::std::os::raw::c_uint;
pub const Leap_Finger_Type_TYPE_THUMB: Leap_Finger_Type = 0;
pub const Leap_Finger_Type_TYPE_INDEX: Leap_Finger_Type = 1;
pub const Leap_Finger_Type_TYPE_MIDDLE: Leap_Finger_Type = 2;
pub const Leap_Finger_Type_TYPE_RING: Leap_Finger_Type = 3;
pub const Leap_Finger_Type_TYPE_PINKY: Leap_Finger_Type = 4;
pub type Leap_Finger_Type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Finger() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Finger>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Finger))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Finger>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Finger))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Finger13jointPositionENS0_5JointE"]
    pub fn Leap_Finger_jointPosition(
        this: *const Leap_Finger,
        jointIx: Leap_Finger_Joint,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Finger4boneENS_4Bone4TypeE"]
    pub fn Leap_Finger_bone(out: *mut Leap_Bone, this: *const Leap_Finger, boneIx: Leap_Bone_Type);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Finger4typeEv"]
    pub fn Leap_Finger_type(this: *const Leap_Finger) -> Leap_Finger_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6Finger7invalidEv"]
    pub fn Leap_Finger_invalid() -> *const Leap_Finger;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6FingerC1EPNS_20FingerImplementationE"]
    pub fn Leap_Finger_Finger(this: *mut Leap_Finger, arg1: *mut Leap_FingerImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6FingerC1Ev"]
    pub fn Leap_Finger_Finger1(this: *mut Leap_Finger);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6FingerC1ERKNS_9PointableE"]
    pub fn Leap_Finger_Finger2(this: *mut Leap_Finger, arg1: *const Leap_Pointable);
}
/*impl Leap_Finger {
    #[inline]
    pub unsafe fn jointPosition(&self, jointIx: Leap_Finger_Joint) -> Leap_Vector {
        Leap_Finger_jointPosition(self, jointIx)
    }
    #[inline]
    pub unsafe fn bone(&self, boneIx: Leap_Bone_Type) -> Leap_Bone {
        Leap_Finger_bone(self, boneIx)
    }
    #[inline]
    pub unsafe fn type_(&self) -> Leap_Finger_Type {
        Leap_Finger_type(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Finger {
        Leap_Finger_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_FingerImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Finger_Finger(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Finger_Finger1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const Leap_Pointable) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Finger_Finger2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Tool {
    pub _base: Leap_Pointable,
}
#[test]
fn bindgen_test_layout_Leap_Tool() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Tool>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Tool))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Tool>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Tool))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4Tool7invalidEv"]
    pub fn Leap_Tool_invalid() -> *const Leap_Tool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4ToolC1EPNS_18ToolImplementationE"]
    pub fn Leap_Tool_Tool(this: *mut Leap_Tool, arg1: *mut Leap_ToolImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4ToolC1Ev"]
    pub fn Leap_Tool_Tool1(this: *mut Leap_Tool);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4ToolC1ERKNS_9PointableE"]
    pub fn Leap_Tool_Tool2(this: *mut Leap_Tool, arg1: *const Leap_Pointable);
}
impl Leap_Tool {
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Tool {
        Leap_Tool_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_ToolImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Tool_Tool(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Tool_Tool1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const Leap_Pointable) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Tool_Tool2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Hand {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_Hand() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Hand>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Hand))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Hand>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Hand))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand2idEv"]
    pub fn Leap_Hand_id(this: *const Leap_Hand) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand5frameEv"]
    pub fn Leap_Hand_frame(out: *mut Leap_Frame, this: *const Leap_Hand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand10pointablesEv"]
    pub fn Leap_Hand_pointables(out: *mut Leap_PointableList, this: *const Leap_Hand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand9pointableEi"]
    pub fn Leap_Hand_pointable(out: *mut Leap_Pointable, this: *const Leap_Hand, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand7fingersEv"]
    pub fn Leap_Hand_fingers(out: *mut Leap_FingerList, this: *const Leap_Hand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand6fingerEi"]
    pub fn Leap_Hand_finger(out: *mut Leap_Finger, this: *const Leap_Hand, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand5toolsEv"]
    pub fn Leap_Hand_tools(out: *mut Leap_ToolList, this: *const Leap_Hand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand4toolEi"]
    pub fn Leap_Hand_tool(out: *mut Leap_Tool, this: *const Leap_Hand, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12palmPositionEv"]
    pub fn Leap_Hand_palmPosition(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand22stabilizedPalmPositionEv"]
    pub fn Leap_Hand_stabilizedPalmPosition(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12palmVelocityEv"]
    pub fn Leap_Hand_palmVelocity(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand10palmNormalEv"]
    pub fn Leap_Hand_palmNormal(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand9palmWidthEv"]
    pub fn Leap_Hand_palmWidth(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand9directionEv"]
    pub fn Leap_Hand_direction(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand5basisEv"]
    pub fn Leap_Hand_basis(this: *const Leap_Hand) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand3armEv"]
    pub fn Leap_Hand_arm(out: *mut Leap_Arm, this: *const Leap_Hand);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand13wristPositionEv"]
    pub fn Leap_Hand_wristPosition(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12sphereCenterEv"]
    pub fn Leap_Hand_sphereCenter(this: *const Leap_Hand) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12sphereRadiusEv"]
    pub fn Leap_Hand_sphereRadius(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand13pinchStrengthEv"]
    pub fn Leap_Hand_pinchStrength(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12grabStrengthEv"]
    pub fn Leap_Hand_grabStrength(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand11translationERKNS_5FrameE"]
    pub fn Leap_Hand_translation(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand22translationProbabilityERKNS_5FrameE"]
    pub fn Leap_Hand_translationProbability(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand12rotationAxisERKNS_5FrameE"]
    pub fn Leap_Hand_rotationAxis(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand13rotationAngleERKNS_5FrameE"]
    pub fn Leap_Hand_rotationAngle(this: *const Leap_Hand, sinceFrame: *const Leap_Frame) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand13rotationAngleERKNS_5FrameERKNS_6VectorE"]
    pub fn Leap_Hand_rotationAngle1(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
        axis: *const Leap_Vector,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand14rotationMatrixERKNS_5FrameE"]
    pub fn Leap_Hand_rotationMatrix(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand19rotationProbabilityERKNS_5FrameE"]
    pub fn Leap_Hand_rotationProbability(
        this: *const Leap_Hand,
        sinceFrame: *const Leap_Frame,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand11scaleFactorERKNS_5FrameE"]
    pub fn Leap_Hand_scaleFactor(this: *const Leap_Hand, sinceFrame: *const Leap_Frame) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand16scaleProbabilityERKNS_5FrameE"]
    pub fn Leap_Hand_scaleProbability(this: *const Leap_Hand, sinceFrame: *const Leap_Frame)
        -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand11timeVisibleEv"]
    pub fn Leap_Hand_timeVisible(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand10confidenceEv"]
    pub fn Leap_Hand_confidence(this: *const Leap_Hand) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand6isLeftEv"]
    pub fn Leap_Hand_isLeft(this: *const Leap_Hand) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand7isRightEv"]
    pub fn Leap_Hand_isRight(this: *const Leap_Hand) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Hand7isValidEv"]
    pub fn Leap_Hand_isValid(this: *const Leap_Hand) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4Hand7invalidEv"]
    pub fn Leap_Hand_invalid() -> *const Leap_Hand;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4HandC1EPNS_18HandImplementationE"]
    pub fn Leap_Hand_Hand(this: *mut Leap_Hand, arg1: *mut Leap_HandImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4HandC1Ev"]
    pub fn Leap_Hand_Hand1(this: *mut Leap_Hand);
}
/*impl Leap_Hand {
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Hand_id(self)
    }
    #[inline]
    pub unsafe fn frame(&self) -> Leap_Frame {
        Leap_Hand_frame(self)
    }
    #[inline]
    pub unsafe fn pointables(&self) -> Leap_PointableList {
        Leap_Hand_pointables(self)
    }
    #[inline]
    pub unsafe fn pointable(&self, id: i32) -> Leap_Pointable {
        Leap_Hand_pointable(self, id)
    }
    #[inline]
    pub unsafe fn fingers(&self) -> Leap_FingerList {
        Leap_Hand_fingers(self)
    }
    #[inline]
    pub unsafe fn finger(&self, id: i32) -> Leap_Finger {
        Leap_Hand_finger(self, id)
    }
    #[inline]
    pub unsafe fn tools(&self) -> Leap_ToolList {
        Leap_Hand_tools(self)
    }
    #[inline]
    pub unsafe fn tool(&self, id: i32) -> Leap_Tool {
        Leap_Hand_tool(self, id)
    }
    #[inline]
    pub unsafe fn palmPosition(&self) -> Leap_Vector {
        Leap_Hand_palmPosition(self)
    }
    #[inline]
    pub unsafe fn stabilizedPalmPosition(&self) -> Leap_Vector {
        Leap_Hand_stabilizedPalmPosition(self)
    }
    #[inline]
    pub unsafe fn palmVelocity(&self) -> Leap_Vector {
        Leap_Hand_palmVelocity(self)
    }
    #[inline]
    pub unsafe fn palmNormal(&self) -> Leap_Vector {
        Leap_Hand_palmNormal(self)
    }
    #[inline]
    pub unsafe fn palmWidth(&self) -> f32 {
        Leap_Hand_palmWidth(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_Hand_direction(self)
    }
    #[inline]
    pub unsafe fn basis(&self) -> Leap_Matrix {
        Leap_Hand_basis(self)
    }
    #[inline]
    pub unsafe fn arm(&self) -> Leap_Arm {
        Leap_Hand_arm(self)
    }
    #[inline]
    pub unsafe fn wristPosition(&self) -> Leap_Vector {
        Leap_Hand_wristPosition(self)
    }
    #[inline]
    pub unsafe fn sphereCenter(&self) -> Leap_Vector {
        Leap_Hand_sphereCenter(self)
    }
    #[inline]
    pub unsafe fn sphereRadius(&self) -> f32 {
        Leap_Hand_sphereRadius(self)
    }
    #[inline]
    pub unsafe fn pinchStrength(&self) -> f32 {
        Leap_Hand_pinchStrength(self)
    }
    #[inline]
    pub unsafe fn grabStrength(&self) -> f32 {
        Leap_Hand_grabStrength(self)
    }
    #[inline]
    pub unsafe fn translation(&self, sinceFrame: *const Leap_Frame) -> Leap_Vector {
        Leap_Hand_translation(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn translationProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Hand_translationProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAxis(&self, sinceFrame: *const Leap_Frame) -> Leap_Vector {
        Leap_Hand_rotationAxis(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAngle(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Hand_rotationAngle(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAngle1(
        &self,
        sinceFrame: *const Leap_Frame,
        axis: *const Leap_Vector,
    ) -> f32 {
        Leap_Hand_rotationAngle1(self, sinceFrame, axis)
    }
    #[inline]
    pub unsafe fn rotationMatrix(&self, sinceFrame: *const Leap_Frame) -> Leap_Matrix {
        Leap_Hand_rotationMatrix(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Hand_rotationProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn scaleFactor(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Hand_scaleFactor(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn scaleProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Hand_scaleProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn timeVisible(&self) -> f32 {
        Leap_Hand_timeVisible(self)
    }
    #[inline]
    pub unsafe fn confidence(&self) -> f32 {
        Leap_Hand_confidence(self)
    }
    #[inline]
    pub unsafe fn isLeft(&self) -> bool {
        Leap_Hand_isLeft(self)
    }
    #[inline]
    pub unsafe fn isRight(&self) -> bool {
        Leap_Hand_isRight(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Hand_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Hand {
        Leap_Hand_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_HandImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Hand_Hand(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Hand_Hand1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Gesture {
    pub _base: Leap_Interface,
}
pub const Leap_Gesture_Type_TYPE_INVALID: Leap_Gesture_Type = -1;
pub const Leap_Gesture_Type_TYPE_SWIPE: Leap_Gesture_Type = 1;
pub const Leap_Gesture_Type_TYPE_CIRCLE: Leap_Gesture_Type = 4;
pub const Leap_Gesture_Type_TYPE_SCREEN_TAP: Leap_Gesture_Type = 5;
pub const Leap_Gesture_Type_TYPE_KEY_TAP: Leap_Gesture_Type = 6;
pub type Leap_Gesture_Type = ::std::os::raw::c_int;
pub const Leap_Gesture_State_STATE_INVALID: Leap_Gesture_State = -1;
pub const Leap_Gesture_State_STATE_START: Leap_Gesture_State = 1;
pub const Leap_Gesture_State_STATE_UPDATE: Leap_Gesture_State = 2;
pub const Leap_Gesture_State_STATE_STOP: Leap_Gesture_State = 3;
pub type Leap_Gesture_State = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_Leap_Gesture() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Gesture>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Gesture))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Gesture>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Gesture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture4typeEv"]
    pub fn Leap_Gesture_type(this: *const Leap_Gesture) -> Leap_Gesture_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture5stateEv"]
    pub fn Leap_Gesture_state(this: *const Leap_Gesture) -> Leap_Gesture_State;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture2idEv"]
    pub fn Leap_Gesture_id(this: *const Leap_Gesture) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture8durationEv"]
    pub fn Leap_Gesture_duration(this: *const Leap_Gesture) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture15durationSecondsEv"]
    pub fn Leap_Gesture_durationSeconds(this: *const Leap_Gesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture5frameEv"]
    pub fn Leap_Gesture_frame(out: *mut Leap_Frame, this: *const Leap_Gesture);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture5handsEv"]
    pub fn Leap_Gesture_hands(out: *mut Leap_HandList, this: *const Leap_Gesture);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture10pointablesEv"]
    pub fn Leap_Gesture_pointables(out: *mut Leap_PointableList, this: *const Leap_Gesture);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap7Gesture7isValidEv"]
    pub fn Leap_Gesture_isValid(this: *const Leap_Gesture) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap7Gesture7invalidEv"]
    pub fn Leap_Gesture_invalid() -> *const Leap_Gesture;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap7GestureC1EPNS_21GestureImplementationE"]
    pub fn Leap_Gesture_Gesture(this: *mut Leap_Gesture, arg1: *mut Leap_GestureImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap7GestureC1Ev"]
    pub fn Leap_Gesture_Gesture1(this: *mut Leap_Gesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap7GestureC1ERKS0_"]
    pub fn Leap_Gesture_Gesture2(this: *mut Leap_Gesture, rhs: *const Leap_Gesture);
}
/*impl Leap_Gesture {
    #[inline]
    pub unsafe fn type_(&self) -> Leap_Gesture_Type {
        Leap_Gesture_type(self)
    }
    #[inline]
    pub unsafe fn state(&self) -> Leap_Gesture_State {
        Leap_Gesture_state(self)
    }
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Gesture_id(self)
    }
    #[inline]
    pub unsafe fn duration(&self) -> i64 {
        Leap_Gesture_duration(self)
    }
    #[inline]
    pub unsafe fn durationSeconds(&self) -> f32 {
        Leap_Gesture_durationSeconds(self)
    }
    #[inline]
    pub unsafe fn frame(&self) -> Leap_Frame {
        Leap_Gesture_frame(self)
    }
    #[inline]
    pub unsafe fn hands(&self) -> Leap_HandList {
        Leap_Gesture_hands(self)
    }
    #[inline]
    pub unsafe fn pointables(&self) -> Leap_PointableList {
        Leap_Gesture_pointables(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Gesture_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Gesture {
        Leap_Gesture_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_GestureImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Gesture_Gesture(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Gesture_Gesture1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *const Leap_Gesture) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Gesture_Gesture2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_SwipeGesture {
    pub _base: Leap_Gesture,
}
#[test]
fn bindgen_test_layout_Leap_SwipeGesture() {
    assert_eq!(
        ::std::mem::size_of::<Leap_SwipeGesture>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_SwipeGesture))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_SwipeGesture>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_SwipeGesture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap12SwipeGesture13startPositionEv"]
    pub fn Leap_SwipeGesture_startPosition(this: *const Leap_SwipeGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap12SwipeGesture8positionEv"]
    pub fn Leap_SwipeGesture_position(this: *const Leap_SwipeGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap12SwipeGesture9directionEv"]
    pub fn Leap_SwipeGesture_direction(this: *const Leap_SwipeGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap12SwipeGesture5speedEv"]
    pub fn Leap_SwipeGesture_speed(this: *const Leap_SwipeGesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap12SwipeGesture9pointableEv"]
    pub fn Leap_SwipeGesture_pointable(out: *mut Leap_Pointable, this: *const Leap_SwipeGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12SwipeGestureC1Ev"]
    pub fn Leap_SwipeGesture_SwipeGesture(this: *mut Leap_SwipeGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12SwipeGestureC1ERKNS_7GestureE"]
    pub fn Leap_SwipeGesture_SwipeGesture1(this: *mut Leap_SwipeGesture, rhs: *const Leap_Gesture);
}
/*impl Leap_SwipeGesture {
    #[inline]
    pub unsafe fn startPosition(&self) -> Leap_Vector {
        Leap_SwipeGesture_startPosition(self)
    }
    #[inline]
    pub unsafe fn position(&self) -> Leap_Vector {
        Leap_SwipeGesture_position(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_SwipeGesture_direction(self)
    }
    #[inline]
    pub unsafe fn speed(&self) -> f32 {
        Leap_SwipeGesture_speed(self)
    }
    #[inline]
    pub unsafe fn pointable(&self) -> Leap_Pointable {
        Leap_SwipeGesture_pointable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_SwipeGesture_SwipeGesture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const Leap_Gesture) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_SwipeGesture_SwipeGesture1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_CircleGesture {
    pub _base: Leap_Gesture,
}
#[test]
fn bindgen_test_layout_Leap_CircleGesture() {
    assert_eq!(
        ::std::mem::size_of::<Leap_CircleGesture>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_CircleGesture))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_CircleGesture>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_CircleGesture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13CircleGesture6centerEv"]
    pub fn Leap_CircleGesture_center(this: *const Leap_CircleGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13CircleGesture6normalEv"]
    pub fn Leap_CircleGesture_normal(this: *const Leap_CircleGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13CircleGesture8progressEv"]
    pub fn Leap_CircleGesture_progress(this: *const Leap_CircleGesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13CircleGesture6radiusEv"]
    pub fn Leap_CircleGesture_radius(this: *const Leap_CircleGesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13CircleGesture9pointableEv"]
    pub fn Leap_CircleGesture_pointable(out: *mut Leap_Pointable, this: *const Leap_CircleGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13CircleGestureC1Ev"]
    pub fn Leap_CircleGesture_CircleGesture(this: *mut Leap_CircleGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13CircleGestureC1ERKNS_7GestureE"]
    pub fn Leap_CircleGesture_CircleGesture1(
        this: *mut Leap_CircleGesture,
        rhs: *const Leap_Gesture,
    );
}
/*impl Leap_CircleGesture {
    #[inline]
    pub unsafe fn center(&self) -> Leap_Vector {
        Leap_CircleGesture_center(self)
    }
    #[inline]
    pub unsafe fn normal(&self) -> Leap_Vector {
        Leap_CircleGesture_normal(self)
    }
    #[inline]
    pub unsafe fn progress(&self) -> f32 {
        Leap_CircleGesture_progress(self)
    }
    #[inline]
    pub unsafe fn radius(&self) -> f32 {
        Leap_CircleGesture_radius(self)
    }
    #[inline]
    pub unsafe fn pointable(&self) -> Leap_Pointable {
        Leap_CircleGesture_pointable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_CircleGesture_CircleGesture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const Leap_Gesture) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_CircleGesture_CircleGesture1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_ScreenTapGesture {
    pub _base: Leap_Gesture,
}
#[test]
fn bindgen_test_layout_Leap_ScreenTapGesture() {
    assert_eq!(
        ::std::mem::size_of::<Leap_ScreenTapGesture>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_ScreenTapGesture))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_ScreenTapGesture>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_ScreenTapGesture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap16ScreenTapGesture8positionEv"]
    pub fn Leap_ScreenTapGesture_position(this: *const Leap_ScreenTapGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap16ScreenTapGesture9directionEv"]
    pub fn Leap_ScreenTapGesture_direction(this: *const Leap_ScreenTapGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap16ScreenTapGesture8progressEv"]
    pub fn Leap_ScreenTapGesture_progress(this: *const Leap_ScreenTapGesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap16ScreenTapGesture9pointableEv"]
    pub fn Leap_ScreenTapGesture_pointable(
        out: *mut Leap_Pointable,
        this: *const Leap_ScreenTapGesture,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap16ScreenTapGestureC1Ev"]
    pub fn Leap_ScreenTapGesture_ScreenTapGesture(this: *mut Leap_ScreenTapGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap16ScreenTapGestureC1ERKNS_7GestureE"]
    pub fn Leap_ScreenTapGesture_ScreenTapGesture1(
        this: *mut Leap_ScreenTapGesture,
        rhs: *const Leap_Gesture,
    );
}
/*impl Leap_ScreenTapGesture {
    #[inline]
    pub unsafe fn position(&self) -> Leap_Vector {
        Leap_ScreenTapGesture_position(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_ScreenTapGesture_direction(self)
    }
    #[inline]
    pub unsafe fn progress(&self) -> f32 {
        Leap_ScreenTapGesture_progress(self)
    }
    #[inline]
    pub unsafe fn pointable(&self) -> Leap_Pointable {
        Leap_ScreenTapGesture_pointable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ScreenTapGesture_ScreenTapGesture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const Leap_Gesture) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ScreenTapGesture_ScreenTapGesture1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_KeyTapGesture {
    pub _base: Leap_Gesture,
}
#[test]
fn bindgen_test_layout_Leap_KeyTapGesture() {
    assert_eq!(
        ::std::mem::size_of::<Leap_KeyTapGesture>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_KeyTapGesture))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_KeyTapGesture>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_KeyTapGesture))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13KeyTapGesture8positionEv"]
    pub fn Leap_KeyTapGesture_position(this: *const Leap_KeyTapGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13KeyTapGesture9directionEv"]
    pub fn Leap_KeyTapGesture_direction(this: *const Leap_KeyTapGesture) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13KeyTapGesture8progressEv"]
    pub fn Leap_KeyTapGesture_progress(this: *const Leap_KeyTapGesture) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13KeyTapGesture9pointableEv"]
    pub fn Leap_KeyTapGesture_pointable(out: *mut Leap_Pointable, this: *const Leap_KeyTapGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13KeyTapGestureC1Ev"]
    pub fn Leap_KeyTapGesture_KeyTapGesture(this: *mut Leap_KeyTapGesture);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13KeyTapGestureC1ERKNS_7GestureE"]
    pub fn Leap_KeyTapGesture_KeyTapGesture1(
        this: *mut Leap_KeyTapGesture,
        rhs: *const Leap_Gesture,
    );
}
/*impl Leap_KeyTapGesture {
    #[inline]
    pub unsafe fn position(&self) -> Leap_Vector {
        Leap_KeyTapGesture_position(self)
    }
    #[inline]
    pub unsafe fn direction(&self) -> Leap_Vector {
        Leap_KeyTapGesture_direction(self)
    }
    #[inline]
    pub unsafe fn progress(&self) -> f32 {
        Leap_KeyTapGesture_progress(self)
    }
    #[inline]
    pub unsafe fn pointable(&self) -> Leap_Pointable {
        Leap_KeyTapGesture_pointable(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_KeyTapGesture_KeyTapGesture(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *const Leap_Gesture) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_KeyTapGesture_KeyTapGesture1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Screen {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_Screen() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Screen>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Screen))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Screen))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen2idEv"]
    pub fn Leap_Screen_id(this: *const Leap_Screen) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen9intersectERKNS_9PointableEbf"]
    pub fn Leap_Screen_intersect(
        this: *const Leap_Screen,
        pointable: *const Leap_Pointable,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen9intersectERKNS_6VectorES3_bf"]
    pub fn Leap_Screen_intersect1(
        this: *const Leap_Screen,
        position: *const Leap_Vector,
        direction: *const Leap_Vector,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen7projectERKNS_6VectorEbf"]
    pub fn Leap_Screen_project(
        this: *const Leap_Screen,
        position: *const Leap_Vector,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen14horizontalAxisEv"]
    pub fn Leap_Screen_horizontalAxis(this: *const Leap_Screen) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen12verticalAxisEv"]
    pub fn Leap_Screen_verticalAxis(this: *const Leap_Screen) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen16bottomLeftCornerEv"]
    pub fn Leap_Screen_bottomLeftCorner(this: *const Leap_Screen) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen6normalEv"]
    pub fn Leap_Screen_normal(this: *const Leap_Screen) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen11widthPixelsEv"]
    pub fn Leap_Screen_widthPixels(this: *const Leap_Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen12heightPixelsEv"]
    pub fn Leap_Screen_heightPixels(this: *const Leap_Screen) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen15distanceToPointERKNS_6VectorE"]
    pub fn Leap_Screen_distanceToPoint(this: *const Leap_Screen, point: *const Leap_Vector) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Screen7isValidEv"]
    pub fn Leap_Screen_isValid(this: *const Leap_Screen) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6Screen7invalidEv"]
    pub fn Leap_Screen_invalid() -> *const Leap_Screen;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6ScreenC1EPNS_20ScreenImplementationE"]
    pub fn Leap_Screen_Screen(this: *mut Leap_Screen, arg1: *mut Leap_ScreenImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6ScreenC1Ev"]
    pub fn Leap_Screen_Screen1(this: *mut Leap_Screen);
}
impl Leap_Screen {
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Screen_id(self)
    }
    #[inline]
    pub unsafe fn intersect(
        &self,
        pointable: *const Leap_Pointable,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector {
        Leap_Screen_intersect(self, pointable, normalize, clampRatio)
    }
    #[inline]
    pub unsafe fn intersect1(
        &self,
        position: *const Leap_Vector,
        direction: *const Leap_Vector,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector {
        Leap_Screen_intersect1(self, position, direction, normalize, clampRatio)
    }
    #[inline]
    pub unsafe fn project(
        &self,
        position: *const Leap_Vector,
        normalize: bool,
        clampRatio: f32,
    ) -> Leap_Vector {
        Leap_Screen_project(self, position, normalize, clampRatio)
    }
    #[inline]
    pub unsafe fn horizontalAxis(&self) -> Leap_Vector {
        Leap_Screen_horizontalAxis(self)
    }
    #[inline]
    pub unsafe fn verticalAxis(&self) -> Leap_Vector {
        Leap_Screen_verticalAxis(self)
    }
    #[inline]
    pub unsafe fn bottomLeftCorner(&self) -> Leap_Vector {
        Leap_Screen_bottomLeftCorner(self)
    }
    #[inline]
    pub unsafe fn normal(&self) -> Leap_Vector {
        Leap_Screen_normal(self)
    }
    #[inline]
    pub unsafe fn widthPixels(&self) -> ::std::os::raw::c_int {
        Leap_Screen_widthPixels(self)
    }
    #[inline]
    pub unsafe fn heightPixels(&self) -> ::std::os::raw::c_int {
        Leap_Screen_heightPixels(self)
    }
    #[inline]
    pub unsafe fn distanceToPoint(&self, point: *const Leap_Vector) -> f32 {
        Leap_Screen_distanceToPoint(self, point)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Screen_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Screen {
        Leap_Screen_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_ScreenImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Screen_Screen(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Screen_Screen1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Device {
    pub _base: Leap_Interface,
}
pub const Leap_Device_Type_TYPE_PERIPHERAL: Leap_Device_Type = 1;
pub const Leap_Device_Type_TYPE_LAPTOP: Leap_Device_Type = 2;
pub const Leap_Device_Type_TYPE_KEYBOARD: Leap_Device_Type = 3;
pub type Leap_Device_Type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Device() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Device>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Device))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Device>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Device))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device19horizontalViewAngleEv"]
    pub fn Leap_Device_horizontalViewAngle(this: *const Leap_Device) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device17verticalViewAngleEv"]
    pub fn Leap_Device_verticalViewAngle(this: *const Leap_Device) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device5rangeEv"]
    pub fn Leap_Device_range(this: *const Leap_Device) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device8baselineEv"]
    pub fn Leap_Device_baseline(this: *const Leap_Device) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device18distanceToBoundaryERKNS_6VectorE"]
    pub fn Leap_Device_distanceToBoundary(
        this: *const Leap_Device,
        position: *const Leap_Vector,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device10isEmbeddedEv"]
    pub fn Leap_Device_isEmbedded(this: *const Leap_Device) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device11isStreamingEv"]
    pub fn Leap_Device_isStreaming(this: *const Leap_Device) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device9isFlippedEv"]
    pub fn Leap_Device_isFlipped(this: *const Leap_Device) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device4typeEv"]
    pub fn Leap_Device_type(this: *const Leap_Device) -> Leap_Device_Type;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device8positionEv"]
    pub fn Leap_Device_position(this: *const Leap_Device) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device11orientationEv"]
    pub fn Leap_Device_orientation(this: *const Leap_Device) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap6Device7isValidEv"]
    pub fn Leap_Device_isValid(this: *const Leap_Device) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6Device7invalidEv"]
    pub fn Leap_Device_invalid() -> *const Leap_Device;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6DeviceC1EPNS_20DeviceImplementationE"]
    pub fn Leap_Device_Device(this: *mut Leap_Device, arg1: *mut Leap_DeviceImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6DeviceC1Ev"]
    pub fn Leap_Device_Device1(this: *mut Leap_Device);
}
impl Leap_Device {
    #[inline]
    pub unsafe fn horizontalViewAngle(&self) -> f32 {
        Leap_Device_horizontalViewAngle(self)
    }
    #[inline]
    pub unsafe fn verticalViewAngle(&self) -> f32 {
        Leap_Device_verticalViewAngle(self)
    }
    #[inline]
    pub unsafe fn range(&self) -> f32 {
        Leap_Device_range(self)
    }
    #[inline]
    pub unsafe fn baseline(&self) -> f32 {
        Leap_Device_baseline(self)
    }
    #[inline]
    pub unsafe fn distanceToBoundary(&self, position: *const Leap_Vector) -> f32 {
        Leap_Device_distanceToBoundary(self, position)
    }
    #[inline]
    pub unsafe fn isEmbedded(&self) -> bool {
        Leap_Device_isEmbedded(self)
    }
    #[inline]
    pub unsafe fn isStreaming(&self) -> bool {
        Leap_Device_isStreaming(self)
    }
    #[inline]
    pub unsafe fn isFlipped(&self) -> bool {
        Leap_Device_isFlipped(self)
    }
    #[inline]
    pub unsafe fn type_(&self) -> Leap_Device_Type {
        Leap_Device_type(self)
    }
    #[inline]
    pub unsafe fn position(&self) -> Leap_Vector {
        Leap_Device_position(self)
    }
    #[inline]
    pub unsafe fn orientation(&self) -> Leap_Matrix {
        Leap_Device_orientation(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Device_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Device {
        Leap_Device_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_DeviceImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Device_Device(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Device_Device1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Image {
    pub _base: Leap_Interface,
}
pub const Leap_Image_FormatType_INFRARED: Leap_Image_FormatType = 0;
pub type Leap_Image_FormatType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Image() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Image>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Image))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Image>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Image))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image10sequenceIdEv"]
    pub fn Leap_Image_sequenceId(this: *const Leap_Image) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image2idEv"]
    pub fn Leap_Image_id(this: *const Leap_Image) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image4dataEv"]
    pub fn Leap_Image_data(this: *const Leap_Image) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image10distortionEv"]
    pub fn Leap_Image_distortion(this: *const Leap_Image) -> *const f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image5widthEv"]
    pub fn Leap_Image_width(this: *const Leap_Image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image6heightEv"]
    pub fn Leap_Image_height(this: *const Leap_Image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image13bytesPerPixelEv"]
    pub fn Leap_Image_bytesPerPixel(this: *const Leap_Image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image6formatEv"]
    pub fn Leap_Image_format(this: *const Leap_Image) -> Leap_Image_FormatType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image15distortionWidthEv"]
    pub fn Leap_Image_distortionWidth(this: *const Leap_Image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image16distortionHeightEv"]
    pub fn Leap_Image_distortionHeight(this: *const Leap_Image) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image10rayOffsetXEv"]
    pub fn Leap_Image_rayOffsetX(this: *const Leap_Image) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image10rayOffsetYEv"]
    pub fn Leap_Image_rayOffsetY(this: *const Leap_Image) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image9rayScaleXEv"]
    pub fn Leap_Image_rayScaleX(this: *const Leap_Image) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image9rayScaleYEv"]
    pub fn Leap_Image_rayScaleY(this: *const Leap_Image) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image7rectifyERKNS_6VectorE"]
    pub fn Leap_Image_rectify(this: *const Leap_Image, uv: *const Leap_Vector) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image4warpERKNS_6VectorE"]
    pub fn Leap_Image_warp(this: *const Leap_Image, xy: *const Leap_Vector) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image9timestampEv"]
    pub fn Leap_Image_timestamp(this: *const Leap_Image) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Image7isValidEv"]
    pub fn Leap_Image_isValid(this: *const Leap_Image) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5Image7invalidEv"]
    pub fn Leap_Image_invalid() -> *const Leap_Image;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5ImageC1EPNS_19ImageImplementationE"]
    pub fn Leap_Image_Image(this: *mut Leap_Image, arg1: *mut Leap_ImageImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5ImageC1Ev"]
    pub fn Leap_Image_Image1(this: *mut Leap_Image);
}
impl Leap_Image {
    #[inline]
    pub unsafe fn sequenceId(&self) -> i64 {
        Leap_Image_sequenceId(self)
    }
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Image_id(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const ::std::os::raw::c_uchar {
        Leap_Image_data(self)
    }
    #[inline]
    pub unsafe fn distortion(&self) -> *const f32 {
        Leap_Image_distortion(self)
    }
    #[inline]
    pub unsafe fn width(&self) -> ::std::os::raw::c_int {
        Leap_Image_width(self)
    }
    #[inline]
    pub unsafe fn height(&self) -> ::std::os::raw::c_int {
        Leap_Image_height(self)
    }
    #[inline]
    pub unsafe fn bytesPerPixel(&self) -> ::std::os::raw::c_int {
        Leap_Image_bytesPerPixel(self)
    }
    #[inline]
    pub unsafe fn format(&self) -> Leap_Image_FormatType {
        Leap_Image_format(self)
    }
    #[inline]
    pub unsafe fn distortionWidth(&self) -> ::std::os::raw::c_int {
        Leap_Image_distortionWidth(self)
    }
    #[inline]
    pub unsafe fn distortionHeight(&self) -> ::std::os::raw::c_int {
        Leap_Image_distortionHeight(self)
    }
    #[inline]
    pub unsafe fn rayOffsetX(&self) -> f32 {
        Leap_Image_rayOffsetX(self)
    }
    #[inline]
    pub unsafe fn rayOffsetY(&self) -> f32 {
        Leap_Image_rayOffsetY(self)
    }
    #[inline]
    pub unsafe fn rayScaleX(&self) -> f32 {
        Leap_Image_rayScaleX(self)
    }
    #[inline]
    pub unsafe fn rayScaleY(&self) -> f32 {
        Leap_Image_rayScaleY(self)
    }
    #[inline]
    pub unsafe fn rectify(&self, uv: *const Leap_Vector) -> Leap_Vector {
        Leap_Image_rectify(self, uv)
    }
    #[inline]
    pub unsafe fn warp(&self, xy: *const Leap_Vector) -> Leap_Vector {
        Leap_Image_warp(self, xy)
    }
    #[inline]
    pub unsafe fn timestamp(&self) -> i64 {
        Leap_Image_timestamp(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Image_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Image {
        Leap_Image_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_ImageImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Image_Image(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Image_Image1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Mask {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_Mask() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Mask>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Mask))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Mask>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Mask))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask10sequenceIdEv"]
    pub fn Leap_Mask_sequenceId(this: *const Leap_Mask) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask2idEv"]
    pub fn Leap_Mask_id(this: *const Leap_Mask) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask4dataEv"]
    pub fn Leap_Mask_data(this: *const Leap_Mask) -> *const ::std::os::raw::c_uchar;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask5widthEv"]
    pub fn Leap_Mask_width(this: *const Leap_Mask) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask6heightEv"]
    pub fn Leap_Mask_height(this: *const Leap_Mask) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask7offsetXEv"]
    pub fn Leap_Mask_offsetX(this: *const Leap_Mask) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask7offsetYEv"]
    pub fn Leap_Mask_offsetY(this: *const Leap_Mask) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap4Mask7isValidEv"]
    pub fn Leap_Mask_isValid(this: *const Leap_Mask) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4Mask7invalidEv"]
    pub fn Leap_Mask_invalid() -> *const Leap_Mask;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4MaskC1EPNS_18MaskImplementationE"]
    pub fn Leap_Mask_Mask(this: *mut Leap_Mask, arg1: *mut Leap_MaskImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap4MaskC1Ev"]
    pub fn Leap_Mask_Mask1(this: *mut Leap_Mask);
}
impl Leap_Mask {
    #[inline]
    pub unsafe fn sequenceId(&self) -> i64 {
        Leap_Mask_sequenceId(self)
    }
    #[inline]
    pub unsafe fn id(&self) -> i32 {
        Leap_Mask_id(self)
    }
    #[inline]
    pub unsafe fn data(&self) -> *const ::std::os::raw::c_uchar {
        Leap_Mask_data(self)
    }
    #[inline]
    pub unsafe fn width(&self) -> ::std::os::raw::c_int {
        Leap_Mask_width(self)
    }
    #[inline]
    pub unsafe fn height(&self) -> ::std::os::raw::c_int {
        Leap_Mask_height(self)
    }
    #[inline]
    pub unsafe fn offsetX(&self) -> ::std::os::raw::c_int {
        Leap_Mask_offsetX(self)
    }
    #[inline]
    pub unsafe fn offsetY(&self) -> ::std::os::raw::c_int {
        Leap_Mask_offsetY(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Mask_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Mask {
        Leap_Mask_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_MaskImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Mask_Mask(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Mask_Mask1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_ConstListIterator<L> {
    pub m_list: *const L,
    pub m_index: ::std::os::raw::c_int,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<L>>,
}
pub type Leap_ConstListIterator_difference_type = isize;
pub type Leap_ConstListIterator_value_type<T> = T;
pub type Leap_ConstListIterator_pointer<T> = *const T;
pub type Leap_ConstListIterator_reference<T> = *const T;
pub type Leap_ConstListIterator_iterator_category = std_forward_iterator_tag;
#[repr(C)]
#[derive(Debug)]
pub struct Leap_PointableList {
    pub _base: Leap_Interface,
}
pub type Leap_PointableList_const_iterator = Leap_ConstListIterator<Leap_PointableList>;
#[test]
fn bindgen_test_layout_Leap_PointableList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_PointableList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_PointableList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_PointableList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_PointableList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList5countEv"]
    pub fn Leap_PointableList_count(this: *const Leap_PointableList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList7isEmptyEv"]
    pub fn Leap_PointableList_isEmpty(this: *const Leap_PointableList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13PointableList6appendERKS0_"]
    pub fn Leap_PointableList_append(
        this: *mut Leap_PointableList,
        other: *const Leap_PointableList,
    ) -> *mut Leap_PointableList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13PointableList6appendERKNS_10FingerListE"]
    pub fn Leap_PointableList_append1(
        this: *mut Leap_PointableList,
        other: *const Leap_FingerList,
    ) -> *mut Leap_PointableList;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13PointableList6appendERKNS_8ToolListE"]
    pub fn Leap_PointableList_append2(
        this: *mut Leap_PointableList,
        other: *const Leap_ToolList,
    ) -> *mut Leap_PointableList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList8leftmostEv"]
    pub fn Leap_PointableList_leftmost(out: *mut Leap_Pointable, this: *const Leap_PointableList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList9rightmostEv"]
    pub fn Leap_PointableList_rightmost(out: *mut Leap_Pointable, this: *const Leap_PointableList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList9frontmostEv"]
    pub fn Leap_PointableList_frontmost(out: *mut Leap_Pointable, this: *const Leap_PointableList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList8extendedEv"]
    pub fn Leap_PointableList_extended(
        out: *mut Leap_PointableList,
        this: *const Leap_PointableList,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList5beginEv"]
    pub fn Leap_PointableList_begin(
        this: *const Leap_PointableList,
    ) -> Leap_PointableList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap13PointableList3endEv"]
    pub fn Leap_PointableList_end(
        this: *const Leap_PointableList,
    ) -> Leap_PointableList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13PointableListC1ERKNS_22ListBaseImplementationINS_9PointableEEE"]
    pub fn Leap_PointableList_PointableList(
        this: *mut Leap_PointableList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap13PointableListC1Ev"]
    pub fn Leap_PointableList_PointableList1(this: *mut Leap_PointableList);
}
/*impl Leap_PointableList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_PointableList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_PointableList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_PointableList) -> *mut Leap_PointableList {
        Leap_PointableList_append(self, other)
    }
    #[inline]
    pub unsafe fn append1(&mut self, other: *const Leap_FingerList) -> *mut Leap_PointableList {
        Leap_PointableList_append1(self, other)
    }
    #[inline]
    pub unsafe fn append2(&mut self, other: *const Leap_ToolList) -> *mut Leap_PointableList {
        Leap_PointableList_append2(self, other)
    }
    #[inline]
    pub unsafe fn leftmost(&self) -> Leap_Pointable {
        Leap_PointableList_leftmost(self)
    }
    #[inline]
    pub unsafe fn rightmost(&self) -> Leap_Pointable {
        Leap_PointableList_rightmost(self)
    }
    #[inline]
    pub unsafe fn frontmost(&self) -> Leap_Pointable {
        Leap_PointableList_frontmost(self)
    }
    #[inline]
    pub unsafe fn extended(&self) -> Leap_PointableList {
        Leap_PointableList_extended(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_PointableList_const_iterator {
        Leap_PointableList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_PointableList_const_iterator {
        Leap_PointableList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_PointableList_PointableList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_PointableList_PointableList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_FingerList {
    pub _base: Leap_Interface,
}
pub type Leap_FingerList_const_iterator = Leap_ConstListIterator<Leap_FingerList>;
#[test]
fn bindgen_test_layout_Leap_FingerList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_FingerList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_FingerList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_FingerList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_FingerList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList5countEv"]
    pub fn Leap_FingerList_count(this: *const Leap_FingerList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList7isEmptyEv"]
    pub fn Leap_FingerList_isEmpty(this: *const Leap_FingerList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10FingerList6appendERKS0_"]
    pub fn Leap_FingerList_append(
        this: *mut Leap_FingerList,
        other: *const Leap_FingerList,
    ) -> *mut Leap_FingerList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList8leftmostEv"]
    pub fn Leap_FingerList_leftmost(out: *mut Leap_Finger, this: *const Leap_FingerList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList9rightmostEv"]
    pub fn Leap_FingerList_rightmost(out: *mut Leap_Finger, this: *const Leap_FingerList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList9frontmostEv"]
    pub fn Leap_FingerList_frontmost(out: *mut Leap_Finger, this: *const Leap_FingerList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList8extendedEv"]
    pub fn Leap_FingerList_extended(out: *mut Leap_FingerList, this: *const Leap_FingerList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList10fingerTypeENS_6Finger4TypeE"]
    pub fn Leap_FingerList_fingerType(
        out: *mut Leap_FingerList,
        this: *const Leap_FingerList,
        type_: Leap_Finger_Type,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList5beginEv"]
    pub fn Leap_FingerList_begin(this: *const Leap_FingerList) -> Leap_FingerList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10FingerList3endEv"]
    pub fn Leap_FingerList_end(this: *const Leap_FingerList) -> Leap_FingerList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10FingerListC1ERKNS_22ListBaseImplementationINS_6FingerEEE"]
    pub fn Leap_FingerList_FingerList(
        this: *mut Leap_FingerList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10FingerListC1Ev"]
    pub fn Leap_FingerList_FingerList1(this: *mut Leap_FingerList);
}
/*impl Leap_FingerList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_FingerList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_FingerList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_FingerList) -> *mut Leap_FingerList {
        Leap_FingerList_append(self, other)
    }
    #[inline]
    pub unsafe fn leftmost(&self) -> Leap_Finger {
        Leap_FingerList_leftmost(self)
    }
    #[inline]
    pub unsafe fn rightmost(&self) -> Leap_Finger {
        Leap_FingerList_rightmost(self)
    }
    #[inline]
    pub unsafe fn frontmost(&self) -> Leap_Finger {
        Leap_FingerList_frontmost(self)
    }
    #[inline]
    pub unsafe fn extended(&self) -> Leap_FingerList {
        Leap_FingerList_extended(self)
    }
    #[inline]
    pub unsafe fn fingerType(&self, type_: Leap_Finger_Type) -> Leap_FingerList {
        Leap_FingerList_fingerType(self, type_)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_FingerList_const_iterator {
        Leap_FingerList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_FingerList_const_iterator {
        Leap_FingerList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_FingerList_FingerList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_FingerList_FingerList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_ToolList {
    pub _base: Leap_Interface,
}
pub type Leap_ToolList_const_iterator = Leap_ConstListIterator<Leap_ToolList>;
#[test]
fn bindgen_test_layout_Leap_ToolList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_ToolList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_ToolList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_ToolList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_ToolList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList5countEv"]
    pub fn Leap_ToolList_count(this: *const Leap_ToolList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList7isEmptyEv"]
    pub fn Leap_ToolList_isEmpty(this: *const Leap_ToolList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8ToolList6appendERKS0_"]
    pub fn Leap_ToolList_append(
        this: *mut Leap_ToolList,
        other: *const Leap_ToolList,
    ) -> *mut Leap_ToolList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList8leftmostEv"]
    pub fn Leap_ToolList_leftmost(out: *mut Leap_Tool, this: *const Leap_ToolList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList9rightmostEv"]
    pub fn Leap_ToolList_rightmost(out: *mut Leap_Tool, this: *const Leap_ToolList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList9frontmostEv"]
    pub fn Leap_ToolList_frontmost(out: *mut Leap_Tool, this: *const Leap_ToolList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList5beginEv"]
    pub fn Leap_ToolList_begin(this: *const Leap_ToolList) -> Leap_ToolList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8ToolList3endEv"]
    pub fn Leap_ToolList_end(this: *const Leap_ToolList) -> Leap_ToolList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8ToolListC1ERKNS_22ListBaseImplementationINS_4ToolEEE"]
    pub fn Leap_ToolList_ToolList(
        this: *mut Leap_ToolList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8ToolListC1Ev"]
    pub fn Leap_ToolList_ToolList1(this: *mut Leap_ToolList);
}
/*impl Leap_ToolList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_ToolList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_ToolList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_ToolList) -> *mut Leap_ToolList {
        Leap_ToolList_append(self, other)
    }
    #[inline]
    pub unsafe fn leftmost(&self) -> Leap_Tool {
        Leap_ToolList_leftmost(self)
    }
    #[inline]
    pub unsafe fn rightmost(&self) -> Leap_Tool {
        Leap_ToolList_rightmost(self)
    }
    #[inline]
    pub unsafe fn frontmost(&self) -> Leap_Tool {
        Leap_ToolList_frontmost(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_ToolList_const_iterator {
        Leap_ToolList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_ToolList_const_iterator {
        Leap_ToolList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ToolList_ToolList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ToolList_ToolList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_HandList {
    pub _base: Leap_Interface,
}
pub type Leap_HandList_const_iterator = Leap_ConstListIterator<Leap_HandList>;
#[test]
fn bindgen_test_layout_Leap_HandList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_HandList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_HandList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_HandList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_HandList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList5countEv"]
    pub fn Leap_HandList_count(this: *const Leap_HandList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList7isEmptyEv"]
    pub fn Leap_HandList_isEmpty(this: *const Leap_HandList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8HandList6appendERKS0_"]
    pub fn Leap_HandList_append(
        this: *mut Leap_HandList,
        other: *const Leap_HandList,
    ) -> *mut Leap_HandList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList8leftmostEv"]
    pub fn Leap_HandList_leftmost(out: *mut Leap_Hand, this: *const Leap_HandList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList9rightmostEv"]
    pub fn Leap_HandList_rightmost(out: *mut Leap_Hand, this: *const Leap_HandList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList9frontmostEv"]
    pub fn Leap_HandList_frontmost(out: *mut Leap_Hand, this: *const Leap_HandList);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList5beginEv"]
    pub fn Leap_HandList_begin(this: *const Leap_HandList) -> Leap_HandList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8HandList3endEv"]
    pub fn Leap_HandList_end(this: *const Leap_HandList) -> Leap_HandList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8HandListC1ERKNS_22ListBaseImplementationINS_4HandEEE"]
    pub fn Leap_HandList_HandList(
        this: *mut Leap_HandList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8HandListC1Ev"]
    pub fn Leap_HandList_HandList1(this: *mut Leap_HandList);
}
/*impl Leap_HandList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_HandList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_HandList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_HandList) -> *mut Leap_HandList {
        Leap_HandList_append(self, other)
    }
    #[inline]
    pub unsafe fn leftmost(&self) -> Leap_Hand {
        Leap_HandList_leftmost(self)
    }
    #[inline]
    pub unsafe fn rightmost(&self) -> Leap_Hand {
        Leap_HandList_rightmost(self)
    }
    #[inline]
    pub unsafe fn frontmost(&self) -> Leap_Hand {
        Leap_HandList_frontmost(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_HandList_const_iterator {
        Leap_HandList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_HandList_const_iterator {
        Leap_HandList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_HandList_HandList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_HandList_HandList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_GestureList {
    pub _base: Leap_Interface,
}
pub type Leap_GestureList_const_iterator = Leap_ConstListIterator<Leap_GestureList>;
#[test]
fn bindgen_test_layout_Leap_GestureList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_GestureList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_GestureList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_GestureList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_GestureList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11GestureList5countEv"]
    pub fn Leap_GestureList_count(this: *const Leap_GestureList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11GestureList7isEmptyEv"]
    pub fn Leap_GestureList_isEmpty(this: *const Leap_GestureList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11GestureList6appendERKS0_"]
    pub fn Leap_GestureList_append(
        this: *mut Leap_GestureList,
        other: *const Leap_GestureList,
    ) -> *mut Leap_GestureList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11GestureList5beginEv"]
    pub fn Leap_GestureList_begin(this: *const Leap_GestureList)
        -> Leap_GestureList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11GestureList3endEv"]
    pub fn Leap_GestureList_end(this: *const Leap_GestureList) -> Leap_GestureList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11GestureListC1ERKNS_22ListBaseImplementationINS_7GestureEEE"]
    pub fn Leap_GestureList_GestureList(
        this: *mut Leap_GestureList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11GestureListC1Ev"]
    pub fn Leap_GestureList_GestureList1(this: *mut Leap_GestureList);
}
impl Leap_GestureList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_GestureList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_GestureList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_GestureList) -> *mut Leap_GestureList {
        Leap_GestureList_append(self, other)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_GestureList_const_iterator {
        Leap_GestureList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_GestureList_const_iterator {
        Leap_GestureList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_GestureList_GestureList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_GestureList_GestureList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_ScreenList {
    pub _base: Leap_Interface,
}
pub type Leap_ScreenList_const_iterator = Leap_ConstListIterator<Leap_ScreenList>;
#[test]
fn bindgen_test_layout_Leap_ScreenList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_ScreenList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_ScreenList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_ScreenList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_ScreenList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList5countEv"]
    pub fn Leap_ScreenList_count(this: *const Leap_ScreenList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList7isEmptyEv"]
    pub fn Leap_ScreenList_isEmpty(this: *const Leap_ScreenList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList5beginEv"]
    pub fn Leap_ScreenList_begin(this: *const Leap_ScreenList) -> Leap_ScreenList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList3endEv"]
    pub fn Leap_ScreenList_end(this: *const Leap_ScreenList) -> Leap_ScreenList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList16closestScreenHitERKNS_9PointableE"]
    pub fn Leap_ScreenList_closestScreenHit(
        this: *const Leap_ScreenList,
        pointable: *const Leap_Pointable,
    ) -> Leap_Screen;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList16closestScreenHitERKNS_6VectorES3_"]
    pub fn Leap_ScreenList_closestScreenHit1(
        this: *const Leap_ScreenList,
        position: *const Leap_Vector,
        direction: *const Leap_Vector,
    ) -> Leap_Screen;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10ScreenList13closestScreenERKNS_6VectorE"]
    pub fn Leap_ScreenList_closestScreen(
        this: *const Leap_ScreenList,
        position: *const Leap_Vector,
    ) -> Leap_Screen;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ScreenListC1ERKNS_22ListBaseImplementationINS_6ScreenEEE"]
    pub fn Leap_ScreenList_ScreenList(
        this: *mut Leap_ScreenList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ScreenListC1Ev"]
    pub fn Leap_ScreenList_ScreenList1(this: *mut Leap_ScreenList);
}
impl Leap_ScreenList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_ScreenList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_ScreenList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_ScreenList_const_iterator {
        Leap_ScreenList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_ScreenList_const_iterator {
        Leap_ScreenList_end(self)
    }
    #[inline]
    pub unsafe fn closestScreenHit(&self, pointable: *const Leap_Pointable) -> Leap_Screen {
        Leap_ScreenList_closestScreenHit(self, pointable)
    }
    #[inline]
    pub unsafe fn closestScreenHit1(
        &self,
        position: *const Leap_Vector,
        direction: *const Leap_Vector,
    ) -> Leap_Screen {
        Leap_ScreenList_closestScreenHit1(self, position, direction)
    }
    #[inline]
    pub unsafe fn closestScreen(&self, position: *const Leap_Vector) -> Leap_Screen {
        Leap_ScreenList_closestScreen(self, position)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ScreenList_ScreenList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ScreenList_ScreenList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_DeviceList {
    pub _base: Leap_Interface,
}
pub type Leap_DeviceList_const_iterator = Leap_ConstListIterator<Leap_DeviceList>;
#[test]
fn bindgen_test_layout_Leap_DeviceList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_DeviceList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_DeviceList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_DeviceList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_DeviceList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10DeviceList5countEv"]
    pub fn Leap_DeviceList_count(this: *const Leap_DeviceList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10DeviceList7isEmptyEv"]
    pub fn Leap_DeviceList_isEmpty(this: *const Leap_DeviceList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10DeviceList6appendERKS0_"]
    pub fn Leap_DeviceList_append(
        this: *mut Leap_DeviceList,
        other: *const Leap_DeviceList,
    ) -> *mut Leap_DeviceList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10DeviceList5beginEv"]
    pub fn Leap_DeviceList_begin(this: *const Leap_DeviceList) -> Leap_DeviceList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10DeviceList3endEv"]
    pub fn Leap_DeviceList_end(this: *const Leap_DeviceList) -> Leap_DeviceList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10DeviceListC1ERKNS_22ListBaseImplementationINS_6DeviceEEE"]
    pub fn Leap_DeviceList_DeviceList(
        this: *mut Leap_DeviceList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10DeviceListC1Ev"]
    pub fn Leap_DeviceList_DeviceList1(this: *mut Leap_DeviceList);
}
impl Leap_DeviceList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_DeviceList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_DeviceList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_DeviceList) -> *mut Leap_DeviceList {
        Leap_DeviceList_append(self, other)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_DeviceList_const_iterator {
        Leap_DeviceList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_DeviceList_const_iterator {
        Leap_DeviceList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_DeviceList_DeviceList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_DeviceList_DeviceList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_ImageList {
    pub _base: Leap_Interface,
}
pub type Leap_ImageList_const_iterator = Leap_ConstListIterator<Leap_ImageList>;
#[test]
fn bindgen_test_layout_Leap_ImageList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_ImageList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_ImageList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_ImageList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_ImageList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9ImageList5countEv"]
    pub fn Leap_ImageList_count(this: *const Leap_ImageList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9ImageList7isEmptyEv"]
    pub fn Leap_ImageList_isEmpty(this: *const Leap_ImageList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9ImageList6appendERKS0_"]
    pub fn Leap_ImageList_append(
        this: *mut Leap_ImageList,
        other: *const Leap_ImageList,
    ) -> *mut Leap_ImageList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9ImageList5beginEv"]
    pub fn Leap_ImageList_begin(this: *const Leap_ImageList) -> Leap_ImageList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9ImageList3endEv"]
    pub fn Leap_ImageList_end(this: *const Leap_ImageList) -> Leap_ImageList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9ImageListC1ERKNS_22ListBaseImplementationINS_5ImageEEE"]
    pub fn Leap_ImageList_ImageList(
        this: *mut Leap_ImageList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9ImageListC1Ev"]
    pub fn Leap_ImageList_ImageList1(this: *mut Leap_ImageList);
}
impl Leap_ImageList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_ImageList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_ImageList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_ImageList) -> *mut Leap_ImageList {
        Leap_ImageList_append(self, other)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_ImageList_const_iterator {
        Leap_ImageList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_ImageList_const_iterator {
        Leap_ImageList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ImageList_ImageList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_ImageList_ImageList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_TrackedQuad {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_TrackedQuad() {
    assert_eq!(
        ::std::mem::size_of::<Leap_TrackedQuad>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_TrackedQuad))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_TrackedQuad>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_TrackedQuad))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad5widthEv"]
    pub fn Leap_TrackedQuad_width(this: *const Leap_TrackedQuad) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad6heightEv"]
    pub fn Leap_TrackedQuad_height(this: *const Leap_TrackedQuad) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad11resolutionXEv"]
    pub fn Leap_TrackedQuad_resolutionX(this: *const Leap_TrackedQuad) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad11resolutionYEv"]
    pub fn Leap_TrackedQuad_resolutionY(this: *const Leap_TrackedQuad) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad7visibleEv"]
    pub fn Leap_TrackedQuad_visible(this: *const Leap_TrackedQuad) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad11orientationEv"]
    pub fn Leap_TrackedQuad_orientation(this: *const Leap_TrackedQuad) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad8positionEv"]
    pub fn Leap_TrackedQuad_position(this: *const Leap_TrackedQuad) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad5masksEv"]
    pub fn Leap_TrackedQuad_masks(this: *const Leap_TrackedQuad) -> Leap_MaskList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad6imagesEv"]
    pub fn Leap_TrackedQuad_images(this: *const Leap_TrackedQuad) -> Leap_ImageList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap11TrackedQuad7isValidEv"]
    pub fn Leap_TrackedQuad_isValid(this: *const Leap_TrackedQuad) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11TrackedQuad7invalidEv"]
    pub fn Leap_TrackedQuad_invalid() -> *const Leap_TrackedQuad;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11TrackedQuadC1EPNS_25TrackedQuadImplementationE"]
    pub fn Leap_TrackedQuad_TrackedQuad(
        this: *mut Leap_TrackedQuad,
        arg1: *mut Leap_TrackedQuadImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap11TrackedQuadC1Ev"]
    pub fn Leap_TrackedQuad_TrackedQuad1(this: *mut Leap_TrackedQuad);
}
impl Leap_TrackedQuad {
    #[inline]
    pub unsafe fn width(&self) -> f32 {
        Leap_TrackedQuad_width(self)
    }
    #[inline]
    pub unsafe fn height(&self) -> f32 {
        Leap_TrackedQuad_height(self)
    }
    #[inline]
    pub unsafe fn resolutionX(&self) -> ::std::os::raw::c_int {
        Leap_TrackedQuad_resolutionX(self)
    }
    #[inline]
    pub unsafe fn resolutionY(&self) -> ::std::os::raw::c_int {
        Leap_TrackedQuad_resolutionY(self)
    }
    #[inline]
    pub unsafe fn visible(&self) -> bool {
        Leap_TrackedQuad_visible(self)
    }
    #[inline]
    pub unsafe fn orientation(&self) -> Leap_Matrix {
        Leap_TrackedQuad_orientation(self)
    }
    #[inline]
    pub unsafe fn position(&self) -> Leap_Vector {
        Leap_TrackedQuad_position(self)
    }
    #[inline]
    pub unsafe fn masks(&self) -> Leap_MaskList {
        Leap_TrackedQuad_masks(self)
    }
    #[inline]
    pub unsafe fn images(&self) -> Leap_ImageList {
        Leap_TrackedQuad_images(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_TrackedQuad_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_TrackedQuad {
        Leap_TrackedQuad_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_TrackedQuadImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_TrackedQuad_TrackedQuad(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_TrackedQuad_TrackedQuad1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_MaskList {
    pub _base: Leap_Interface,
}
pub type Leap_MaskList_const_iterator = Leap_ConstListIterator<Leap_MaskList>;
#[test]
fn bindgen_test_layout_Leap_MaskList() {
    assert_eq!(
        ::std::mem::size_of::<Leap_MaskList>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_MaskList))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_MaskList>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_MaskList))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8MaskList5countEv"]
    pub fn Leap_MaskList_count(this: *const Leap_MaskList) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8MaskList7isEmptyEv"]
    pub fn Leap_MaskList_isEmpty(this: *const Leap_MaskList) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8MaskList6appendERKS0_"]
    pub fn Leap_MaskList_append(
        this: *mut Leap_MaskList,
        other: *const Leap_MaskList,
    ) -> *mut Leap_MaskList;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8MaskList5beginEv"]
    pub fn Leap_MaskList_begin(this: *const Leap_MaskList) -> Leap_MaskList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap8MaskList3endEv"]
    pub fn Leap_MaskList_end(this: *const Leap_MaskList) -> Leap_MaskList_const_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8MaskListC1ERKNS_22ListBaseImplementationINS_4MaskEEE"]
    pub fn Leap_MaskList_MaskList(
        this: *mut Leap_MaskList,
        arg1: *const Leap_ListBaseImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap8MaskListC1Ev"]
    pub fn Leap_MaskList_MaskList1(this: *mut Leap_MaskList);
}
impl Leap_MaskList {
    #[inline]
    pub unsafe fn count(&self) -> ::std::os::raw::c_int {
        Leap_MaskList_count(self)
    }
    #[inline]
    pub unsafe fn isEmpty(&self) -> bool {
        Leap_MaskList_isEmpty(self)
    }
    #[inline]
    pub unsafe fn append(&mut self, other: *const Leap_MaskList) -> *mut Leap_MaskList {
        Leap_MaskList_append(self, other)
    }
    #[inline]
    pub unsafe fn begin(&self) -> Leap_MaskList_const_iterator {
        Leap_MaskList_begin(self)
    }
    #[inline]
    pub unsafe fn end(&self) -> Leap_MaskList_const_iterator {
        Leap_MaskList_end(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *const Leap_ListBaseImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_MaskList_MaskList(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_MaskList_MaskList1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_InteractionBox {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_InteractionBox() {
    assert_eq!(
        ::std::mem::size_of::<Leap_InteractionBox>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_InteractionBox))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_InteractionBox>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_InteractionBox))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox14normalizePointERKNS_6VectorEb"]
    pub fn Leap_InteractionBox_normalizePoint(
        this: *const Leap_InteractionBox,
        position: *const Leap_Vector,
        clamp: bool,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox16denormalizePointERKNS_6VectorE"]
    pub fn Leap_InteractionBox_denormalizePoint(
        this: *const Leap_InteractionBox,
        normalizedPosition: *const Leap_Vector,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox6centerEv"]
    pub fn Leap_InteractionBox_center(this: *const Leap_InteractionBox) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox5widthEv"]
    pub fn Leap_InteractionBox_width(this: *const Leap_InteractionBox) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox6heightEv"]
    pub fn Leap_InteractionBox_height(this: *const Leap_InteractionBox) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox5depthEv"]
    pub fn Leap_InteractionBox_depth(this: *const Leap_InteractionBox) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap14InteractionBox7isValidEv"]
    pub fn Leap_InteractionBox_isValid(this: *const Leap_InteractionBox) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap14InteractionBox7invalidEv"]
    pub fn Leap_InteractionBox_invalid() -> *const Leap_InteractionBox;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap14InteractionBoxC1EPNS_28InteractionBoxImplementationE"]
    pub fn Leap_InteractionBox_InteractionBox(
        this: *mut Leap_InteractionBox,
        arg1: *mut Leap_InteractionBoxImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap14InteractionBoxC1Ev"]
    pub fn Leap_InteractionBox_InteractionBox1(this: *mut Leap_InteractionBox);
}
impl Leap_InteractionBox {
    #[inline]
    pub unsafe fn normalizePoint(&self, position: *const Leap_Vector, clamp: bool) -> Leap_Vector {
        Leap_InteractionBox_normalizePoint(self, position, clamp)
    }
    #[inline]
    pub unsafe fn denormalizePoint(&self, normalizedPosition: *const Leap_Vector) -> Leap_Vector {
        Leap_InteractionBox_denormalizePoint(self, normalizedPosition)
    }
    #[inline]
    pub unsafe fn center(&self) -> Leap_Vector {
        Leap_InteractionBox_center(self)
    }
    #[inline]
    pub unsafe fn width(&self) -> f32 {
        Leap_InteractionBox_width(self)
    }
    #[inline]
    pub unsafe fn height(&self) -> f32 {
        Leap_InteractionBox_height(self)
    }
    #[inline]
    pub unsafe fn depth(&self) -> f32 {
        Leap_InteractionBox_depth(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_InteractionBox_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_InteractionBox {
        Leap_InteractionBox_invalid()
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_InteractionBoxImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_InteractionBox_InteractionBox(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_InteractionBox_InteractionBox1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Frame {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_Frame() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Frame>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Frame))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Frame>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Frame))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame2idEv"]
    pub fn Leap_Frame_id(this: *const Leap_Frame) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame9timestampEv"]
    pub fn Leap_Frame_timestamp(this: *const Leap_Frame) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame5handsEv"]
    pub fn Leap_Frame_hands(out: *mut Leap_HandList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame4handEi"]
    pub fn Leap_Frame_hand(out: *mut Leap_Hand, this: *const Leap_Frame, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame10pointablesEv"]
    pub fn Leap_Frame_pointables(out: *mut Leap_PointableList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame9pointableEi"]
    pub fn Leap_Frame_pointable(out: *mut Leap_Pointable, this: *const Leap_Frame, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame7fingersEv"]
    pub fn Leap_Frame_fingers(out: *mut Leap_FingerList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame6fingerEi"]
    pub fn Leap_Frame_finger(out: *mut Leap_Finger, this: *const Leap_Frame, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame5toolsEv"]
    pub fn Leap_Frame_tools(out: *mut Leap_ToolList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame4toolEi"]
    pub fn Leap_Frame_tool(out: *mut Leap_Tool, this: *const Leap_Frame, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame7gestureEi"]
    pub fn Leap_Frame_gesture(out: *mut Leap_Gesture, this: *const Leap_Frame, id: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame8gesturesEv"]
    pub fn Leap_Frame_gestures(out: *mut Leap_GestureList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame8gesturesERKS0_"]
    pub fn Leap_Frame_gestures1(
        out: *mut Leap_GestureList,
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame6imagesEv"]
    pub fn Leap_Frame_images(out: *mut Leap_ImageList, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame11translationERKS0_"]
    pub fn Leap_Frame_translation(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame22translationProbabilityERKS0_"]
    pub fn Leap_Frame_translationProbability(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame12rotationAxisERKS0_"]
    pub fn Leap_Frame_rotationAxis(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Vector;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame13rotationAngleERKS0_"]
    pub fn Leap_Frame_rotationAngle(this: *const Leap_Frame, sinceFrame: *const Leap_Frame) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame13rotationAngleERKS0_RKNS_6VectorE"]
    pub fn Leap_Frame_rotationAngle1(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
        axis: *const Leap_Vector,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame14rotationMatrixERKS0_"]
    pub fn Leap_Frame_rotationMatrix(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> Leap_Matrix;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame19rotationProbabilityERKS0_"]
    pub fn Leap_Frame_rotationProbability(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame11scaleFactorERKS0_"]
    pub fn Leap_Frame_scaleFactor(this: *const Leap_Frame, sinceFrame: *const Leap_Frame) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame16scaleProbabilityERKS0_"]
    pub fn Leap_Frame_scaleProbability(
        this: *const Leap_Frame,
        sinceFrame: *const Leap_Frame,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame14interactionBoxEv"]
    pub fn Leap_Frame_interactionBox(out: *mut Leap_InteractionBox, this: *const Leap_Frame);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame22currentFramesPerSecondEv"]
    pub fn Leap_Frame_currentFramesPerSecond(this: *const Leap_Frame) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame7isValidEv"]
    pub fn Leap_Frame_isValid(this: *const Leap_Frame) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5Frame7invalidEv"]
    pub fn Leap_Frame_invalid() -> *const Leap_Frame;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap5Frame11trackedQuadEv"]
    pub fn Leap_Frame_trackedQuad(this: *const Leap_Frame) -> Leap_TrackedQuad;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5FrameC1EPNS_19FrameImplementationE"]
    pub fn Leap_Frame_Frame(this: *mut Leap_Frame, arg1: *mut Leap_FrameImplementation);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap5FrameC1Ev"]
    pub fn Leap_Frame_Frame1(this: *mut Leap_Frame);
}
/*impl Leap_Frame {
    #[inline]
    pub unsafe fn id(&self) -> i64 {
        Leap_Frame_id(self)
    }
    #[inline]
    pub unsafe fn timestamp(&self) -> i64 {
        Leap_Frame_timestamp(self)
    }
    #[inline]
    pub unsafe fn hands(&self) -> Leap_HandList {
        Leap_Frame_hands(self)
    }
    #[inline]
    pub unsafe fn hand(&self, id: i32) -> Leap_Hand {
        Leap_Frame_hand(self, id)
    }
    #[inline]
    pub unsafe fn pointables(&self) -> Leap_PointableList {
        Leap_Frame_pointables(self)
    }
    #[inline]
    pub unsafe fn pointable(&self, id: i32) -> Leap_Pointable {
        Leap_Frame_pointable(self, id)
    }
    #[inline]
    pub unsafe fn fingers(&self) -> Leap_FingerList {
        Leap_Frame_fingers(self)
    }
    #[inline]
    pub unsafe fn finger(&self, id: i32) -> Leap_Finger {
        Leap_Frame_finger(self, id)
    }
    #[inline]
    pub unsafe fn tools(&self) -> Leap_ToolList {
        Leap_Frame_tools(self)
    }
    #[inline]
    pub unsafe fn tool(&self, id: i32) -> Leap_Tool {
        Leap_Frame_tool(self, id)
    }
    #[inline]
    pub unsafe fn gesture(&self, id: i32) -> Leap_Gesture {
        Leap_Frame_gesture(self, id)
    }
    #[inline]
    pub unsafe fn gestures(&self) -> Leap_GestureList {
        Leap_Frame_gestures(self)
    }
    #[inline]
    pub unsafe fn gestures1(&self, sinceFrame: *const Leap_Frame) -> Leap_GestureList {
        Leap_Frame_gestures1(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn images(&self) -> Leap_ImageList {
        Leap_Frame_images(self)
    }
    #[inline]
    pub unsafe fn translation(&self, sinceFrame: *const Leap_Frame) -> Leap_Vector {
        Leap_Frame_translation(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn translationProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Frame_translationProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAxis(&self, sinceFrame: *const Leap_Frame) -> Leap_Vector {
        Leap_Frame_rotationAxis(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAngle(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Frame_rotationAngle(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationAngle1(
        &self,
        sinceFrame: *const Leap_Frame,
        axis: *const Leap_Vector,
    ) -> f32 {
        Leap_Frame_rotationAngle1(self, sinceFrame, axis)
    }
    #[inline]
    pub unsafe fn rotationMatrix(&self, sinceFrame: *const Leap_Frame) -> Leap_Matrix {
        Leap_Frame_rotationMatrix(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn rotationProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Frame_rotationProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn scaleFactor(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Frame_scaleFactor(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn scaleProbability(&self, sinceFrame: *const Leap_Frame) -> f32 {
        Leap_Frame_scaleProbability(self, sinceFrame)
    }
    #[inline]
    pub unsafe fn interactionBox(&self) -> Leap_InteractionBox {
        Leap_Frame_interactionBox(self)
    }
    #[inline]
    pub unsafe fn currentFramesPerSecond(&self) -> f32 {
        Leap_Frame_currentFramesPerSecond(self)
    }
    #[inline]
    pub unsafe fn isValid(&self) -> bool {
        Leap_Frame_isValid(self)
    }
    #[inline]
    pub unsafe fn invalid() -> *const Leap_Frame {
        Leap_Frame_invalid()
    }
    #[inline]
    pub unsafe fn trackedQuad(&self) -> Leap_TrackedQuad {
        Leap_Frame_trackedQuad(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_FrameImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Frame_Frame(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Frame_Frame1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}*/
#[repr(C)]
#[derive(Debug)]
pub struct Leap_BugReport {
    pub _base: Leap_Interface,
}
#[test]
fn bindgen_test_layout_Leap_BugReport() {
    assert_eq!(
        ::std::mem::size_of::<Leap_BugReport>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_BugReport))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_BugReport>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_BugReport))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9BugReport14beginRecordingEv"]
    pub fn Leap_BugReport_beginRecording(this: *mut Leap_BugReport) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9BugReport12endRecordingEv"]
    pub fn Leap_BugReport_endRecording(this: *mut Leap_BugReport);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9BugReport8isActiveEv"]
    pub fn Leap_BugReport_isActive(this: *const Leap_BugReport) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9BugReport8progressEv"]
    pub fn Leap_BugReport_progress(this: *const Leap_BugReport) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap9BugReport8durationEv"]
    pub fn Leap_BugReport_duration(this: *const Leap_BugReport) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9BugReportC1EPNS_23BugReportImplementationE"]
    pub fn Leap_BugReport_BugReport(
        this: *mut Leap_BugReport,
        arg1: *mut Leap_BugReportImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap9BugReportC1Ev"]
    pub fn Leap_BugReport_BugReport1(this: *mut Leap_BugReport);
}
impl Leap_BugReport {
    #[inline]
    pub unsafe fn beginRecording(&mut self) -> bool {
        Leap_BugReport_beginRecording(self)
    }
    #[inline]
    pub unsafe fn endRecording(&mut self) {
        Leap_BugReport_endRecording(self)
    }
    #[inline]
    pub unsafe fn isActive(&self) -> bool {
        Leap_BugReport_isActive(self)
    }
    #[inline]
    pub unsafe fn progress(&self) -> f32 {
        Leap_BugReport_progress(self)
    }
    #[inline]
    pub unsafe fn duration(&self) -> f32 {
        Leap_BugReport_duration(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_BugReportImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_BugReport_BugReport(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_BugReport_BugReport1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Config {
    pub _base: Leap_Interface,
}
pub const Leap_Config_ValueType_TYPE_UNKNOWN: Leap_Config_ValueType = 0;
pub const Leap_Config_ValueType_TYPE_BOOLEAN: Leap_Config_ValueType = 1;
pub const Leap_Config_ValueType_TYPE_INT32: Leap_Config_ValueType = 2;
pub const Leap_Config_ValueType_TYPE_FLOAT: Leap_Config_ValueType = 6;
pub const Leap_Config_ValueType_TYPE_STRING: Leap_Config_ValueType = 8;
pub type Leap_Config_ValueType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Config() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Config>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Config))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Config>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Config))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6Config4saveEv"]
    pub fn Leap_Config_save(this: *mut Leap_Config) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap6ConfigC1Ev"]
    pub fn Leap_Config_Config(this: *mut Leap_Config);
}
impl Leap_Config {
    #[inline]
    pub unsafe fn save(&mut self) -> bool {
        Leap_Config_save(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Config_Config(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Controller {
    pub _base: Leap_Interface,
}
pub const Leap_Controller_PolicyFlag_POLICY_DEFAULT: Leap_Controller_PolicyFlag = 0;
pub const Leap_Controller_PolicyFlag_POLICY_BACKGROUND_FRAMES: Leap_Controller_PolicyFlag = 1;
pub const Leap_Controller_PolicyFlag_POLICY_IMAGES: Leap_Controller_PolicyFlag = 2;
pub const Leap_Controller_PolicyFlag_POLICY_OPTIMIZE_HMD: Leap_Controller_PolicyFlag = 4;
pub type Leap_Controller_PolicyFlag = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Leap_Controller() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Controller>(),
        16usize,
        concat!("Size of: ", stringify!(Leap_Controller))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Controller>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Controller))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller11isConnectedEv"]
    pub fn Leap_Controller_isConnected(this: *const Leap_Controller) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller18isServiceConnectedEv"]
    pub fn Leap_Controller_isServiceConnected(this: *const Leap_Controller) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller8hasFocusEv"]
    pub fn Leap_Controller_hasFocus(this: *const Leap_Controller) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller11policyFlagsEv"]
    pub fn Leap_Controller_policyFlags(this: *const Leap_Controller) -> Leap_Controller_PolicyFlag;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller14setPolicyFlagsENS0_10PolicyFlagE"]
    pub fn Leap_Controller_setPolicyFlags(
        this: *const Leap_Controller,
        flags: Leap_Controller_PolicyFlag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller9setPolicyENS0_10PolicyFlagE"]
    pub fn Leap_Controller_setPolicy(
        this: *const Leap_Controller,
        policy: Leap_Controller_PolicyFlag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller11clearPolicyENS0_10PolicyFlagE"]
    pub fn Leap_Controller_clearPolicy(
        this: *const Leap_Controller,
        policy: Leap_Controller_PolicyFlag,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller11isPolicySetENS0_10PolicyFlagE"]
    pub fn Leap_Controller_isPolicySet(
        this: *const Leap_Controller,
        policy: Leap_Controller_PolicyFlag,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10Controller11addListenerERNS_8ListenerE"]
    pub fn Leap_Controller_addListener(
        this: *mut Leap_Controller,
        listener: *mut Leap_Listener,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10Controller14removeListenerERNS_8ListenerE"]
    pub fn Leap_Controller_removeListener(
        this: *mut Leap_Controller,
        listener: *mut Leap_Listener,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller5frameEi"]
    pub fn Leap_Controller_frame(
        out: *mut Leap_Frame,
        this: *const Leap_Controller,
        history: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller6imagesEv"]
    pub fn Leap_Controller_images(out: *mut Leap_ImageList, this: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller6configEv"]
    pub fn Leap_Controller_config(out: *mut Leap_Config, this: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller7devicesEv"]
    pub fn Leap_Controller_devices(out: *mut Leap_DeviceList, this: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller14locatedScreensEv"]
    pub fn Leap_Controller_locatedScreens(out: *mut Leap_ScreenList, this: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller9bugReportEv"]
    pub fn Leap_Controller_bugReport(this: *const Leap_Controller) -> Leap_BugReport;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller13enableGestureENS_7Gesture4TypeEb"]
    pub fn Leap_Controller_enableGesture(
        this: *const Leap_Controller,
        type_: Leap_Gesture_Type,
        enable: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller16isGestureEnabledENS_7Gesture4TypeE"]
    pub fn Leap_Controller_isGestureEnabled(
        this: *const Leap_Controller,
        type_: Leap_Gesture_Type,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller11trackedQuadEv"]
    pub fn Leap_Controller_trackedQuad(this: *const Leap_Controller) -> Leap_TrackedQuad;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4Leap10Controller3nowEv"]
    pub fn Leap_Controller_now(this: *const Leap_Controller) -> i64;
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ControllerC1EPNS_24ControllerImplementationE"]
    pub fn Leap_Controller_Controller(
        this: *mut Leap_Controller,
        arg1: *mut Leap_ControllerImplementation,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ControllerC1Ev"]
    pub fn Leap_Controller_Controller1(this: *mut Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ControllerC1ERNS_8ListenerE"]
    pub fn Leap_Controller_Controller2(this: *mut Leap_Controller, listener: *mut Leap_Listener);
}
/*impl Leap_Controller {
    #[inline]
    pub unsafe fn isConnected(&self) -> bool {
        Leap_Controller_isConnected(self)
    }
    #[inline]
    pub unsafe fn isServiceConnected(&self) -> bool {
        Leap_Controller_isServiceConnected(self)
    }
    #[inline]
    pub unsafe fn hasFocus(&self) -> bool {
        Leap_Controller_hasFocus(self)
    }
    #[inline]
    pub unsafe fn policyFlags(&self) -> Leap_Controller_PolicyFlag {
        Leap_Controller_policyFlags(self)
    }
    #[inline]
    pub unsafe fn setPolicyFlags(&self, flags: Leap_Controller_PolicyFlag) {
        Leap_Controller_setPolicyFlags(self, flags)
    }
    #[inline]
    pub unsafe fn setPolicy(&self, policy: Leap_Controller_PolicyFlag) {
        Leap_Controller_setPolicy(self, policy)
    }
    #[inline]
    pub unsafe fn clearPolicy(&self, policy: Leap_Controller_PolicyFlag) {
        Leap_Controller_clearPolicy(self, policy)
    }
    #[inline]
    pub unsafe fn isPolicySet(&self, policy: Leap_Controller_PolicyFlag) -> bool {
        Leap_Controller_isPolicySet(self, policy)
    }
    #[inline]
    pub unsafe fn addListener(&mut self, listener: *mut Leap_Listener) -> bool {
        Leap_Controller_addListener(self, listener)
    }
    #[inline]
    pub unsafe fn removeListener(&mut self, listener: *mut Leap_Listener) -> bool {
        Leap_Controller_removeListener(self, listener)
    }
    #[inline]
    pub unsafe fn frame(&self, history: ::std::os::raw::c_int) -> Leap_Frame {
        Leap_Controller_frame(self, history)
    }
    #[inline]
    pub unsafe fn images(&self) -> Leap_ImageList {
        Leap_Controller_images(self)
    }
    #[inline]
    pub unsafe fn config(&self) -> Leap_Config {
        Leap_Controller_config(self)
    }
    #[inline]
    pub unsafe fn devices(&self) -> Leap_DeviceList {
        Leap_Controller_devices(self)
    }
    #[inline]
    pub unsafe fn locatedScreens(&self) -> Leap_ScreenList {
        Leap_Controller_locatedScreens(self)
    }
    #[inline]
    pub unsafe fn bugReport(&self) -> Leap_BugReport {
        Leap_Controller_bugReport(self)
    }
    #[inline]
    pub unsafe fn enableGesture(&self, type_: Leap_Gesture_Type, enable: bool) {
        Leap_Controller_enableGesture(self, type_, enable)
    }
    #[inline]
    pub unsafe fn isGestureEnabled(&self, type_: Leap_Gesture_Type) -> bool {
        Leap_Controller_isGestureEnabled(self, type_)
    }
    #[inline]
    pub unsafe fn trackedQuad(&self) -> Leap_TrackedQuad {
        Leap_Controller_trackedQuad(self)
    }
    #[inline]
    pub unsafe fn now(&self) -> i64 {
        Leap_Controller_now(self)
    }
    #[inline]
    pub unsafe fn new(arg1: *mut Leap_ControllerImplementation) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Controller_Controller(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Controller_Controller1(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(listener: *mut Leap_Listener) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_Controller_Controller2(__bindgen_tmp.as_mut_ptr(), listener);
        __bindgen_tmp.assume_init()
    }
}*/
extern "C" {
    #[link_name = "\u{1}_ZN4Leap10ControllerD1Ev"]
    pub fn Leap_Controller_Controller_destructor(this: *mut Leap_Controller);
}
#[repr(C)]
pub struct Leap_Listener__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct Leap_Listener {
    pub vtable_: *const Leap_Listener__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_Leap_Listener() {
    assert_eq!(
        ::std::mem::size_of::<Leap_Listener>(),
        8usize,
        concat!("Size of: ", stringify!(Leap_Listener))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_Listener>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_Listener))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Leap_RustListenerCallbacks {
    pub onInit: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onConnect: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onDisconnect: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onExit: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onFrame: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onFocusGained: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onFocusLost: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onServiceConnect: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onServiceDisconnect: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onDeviceChange: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub onImages: ::std::option::Option<
        unsafe extern "C" fn(userdata: *mut ::std::os::raw::c_void, arg1: *const Leap_Controller),
    >,
    pub userdata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Leap_RustListenerCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<Leap_RustListenerCallbacks>(),
        96usize,
        concat!("Size of: ", stringify!(Leap_RustListenerCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_RustListenerCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_RustListenerCallbacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onInit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onInit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onConnect as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onConnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onDisconnect as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onDisconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onExit as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onExit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onFrame as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onFrame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onFocusGained as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onFocusGained)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onFocusLost as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onFocusLost)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onServiceConnect as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onServiceConnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onServiceDisconnect as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onServiceDisconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onDeviceChange as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onDeviceChange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).onImages as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(onImages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Leap_RustListenerCallbacks>())).userdata as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListenerCallbacks),
            "::",
            stringify!(userdata)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct Leap_RustListener {
    pub _base: Leap_Listener,
    pub m_callbacks: Leap_RustListenerCallbacks,
}
#[test]
fn bindgen_test_layout_Leap_RustListener() {
    assert_eq!(
        ::std::mem::size_of::<Leap_RustListener>(),
        104usize,
        concat!("Size of: ", stringify!(Leap_RustListener))
    );
    assert_eq!(
        ::std::mem::align_of::<Leap_RustListener>(),
        8usize,
        concat!("Alignment of ", stringify!(Leap_RustListener))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Leap_RustListener>())).m_callbacks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Leap_RustListener),
            "::",
            stringify!(m_callbacks)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListenerC1ENS_21RustListenerCallbacksE"]
    pub fn Leap_RustListener_RustListener(
        this: *mut Leap_RustListener,
        callbacks: Leap_RustListenerCallbacks,
    );
}
impl Leap_RustListener {
    #[inline]
    pub unsafe fn new(callbacks: Leap_RustListenerCallbacks) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        Leap_RustListener_RustListener(__bindgen_tmp.as_mut_ptr(), callbacks);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener6onInitERKNS_10ControllerE"]
    pub fn Leap_RustListener_onInit(this: *mut ::std::os::raw::c_void, c: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener9onConnectERKNS_10ControllerE"]
    pub fn Leap_RustListener_onConnect(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener12onDisconnectERKNS_10ControllerE"]
    pub fn Leap_RustListener_onDisconnect(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener6onExitERKNS_10ControllerE"]
    pub fn Leap_RustListener_onExit(this: *mut ::std::os::raw::c_void, c: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener7onFrameERKNS_10ControllerE"]
    pub fn Leap_RustListener_onFrame(this: *mut ::std::os::raw::c_void, c: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener13onFocusGainedERKNS_10ControllerE"]
    pub fn Leap_RustListener_onFocusGained(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener11onFocusLostERKNS_10ControllerE"]
    pub fn Leap_RustListener_onFocusLost(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener16onServiceConnectERKNS_10ControllerE"]
    pub fn Leap_RustListener_onServiceConnect(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener19onServiceDisconnectERKNS_10ControllerE"]
    pub fn Leap_RustListener_onServiceDisconnect(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener14onDeviceChangeERKNS_10ControllerE"]
    pub fn Leap_RustListener_onDeviceChange(
        this: *mut ::std::os::raw::c_void,
        c: *const Leap_Controller,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustListener8onImagesERKNS_10ControllerE"]
    pub fn Leap_RustListener_onImages(this: *mut ::std::os::raw::c_void, c: *const Leap_Controller);
}
extern "C" {
    #[link_name = "\u{1}_ZN4Leap12RustGetImageERKNS_9ImageListEi"]
    pub fn Leap_RustGetImage(
        out: *mut Leap_Image,
        list: *const Leap_ImageList,
        index: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SharedObject {
    _unused: [u8; 0],
}
